# 2. レンダーパスとは?

# そもそもパス(Pass)とは？
- Pass
GPUが画面に何かを描画する1回の処理単位
``1Pass = 1回のドローコール = 1つの物体を1回描画``

# レンダリングパス
> レンダリングパスは、ライティングとシェーディングに関連する一連の操作である。パスが異なると、機能とパフォーマンス特性も異なります。どのレンダリングパスがプロジェクトに最も適しているかは、プロジェクトのタイプとターゲットハードウェアによって異なります。

Rendering する際の一連の処理手順をどのように実行するかのこと。具体的には、
- ライティング(光の計算)
- シェーディング(陰影の計算)
オブジェクト自体の表面の明暗を計算する処理
- 影の描画
あるオブジェクトが他のオブジェクトに落とす影を描画する処理
- 透明度処理

# フォワードレンダリングパス(マルチパス)

> (マルチパス) フォワードレンダリングパス を使用すると、シーン内のすべてのオブジェクトが 1 つずつ順番にレンダリングされます。各オブジェクトに影響を与えるライトの数に応じて、それが複数のパスで行われる可能性があります。そのため、そのレンダリングコストは、オブジェクトが複数のライトによって照らされると著しく増加します。このタイプのレンダラーは一般的に、さまざまなシェーダーを提供し、簡単に透明度を処理できます。

>フォワードレンダリングは、ビルトインレンダーパイプラインのデフォルトで、汎用のレンダリングパスです。
リアルタイムのライトは、フォワードレンダリングで描画するには非常に負荷がかかります。このコストを相殺するために、Unity が一度にピクセルごとにレンダリングするライトの数を選択できます。シーンの残りのライトは、頂点ごと、またはオブジェクトごとなど、より低い忠実度で描画されます。
プロジェクトで大量のリアルタイムライトを使用しない場合、またはライティングの忠実度がプロジェクトにとって重要でない場合は、このレンダリングパスがプロジェクトに適していると考えて良いでしょう。

詳しくは [フォワードレンダリングパス](https://docs.unity3d.com/ja/2023.2/Manual/RenderTech-ForwardRendering.html) を参照。


# ディファードレンダリングパス

> ディファードレンダリングパス を使用すると、すべての (不透明な) ジオメトリが最初にバッファにレンダリングされ、バッファはマテリアルに関する情報 (カラー、スペキュラー、スムースネスなど) に関する情報を格納します。後のパス (つまり、“ディファード”) では、各ピクセルは順にシェーディングされます。レンダリング時間は主に各ピクセルに影響を与えるライトの数に依存します。透明なオブジェクトと複雑なシェーダーを持つ特定のオブジェクトは、追加のフォワードレンダリングパスを必要とします。ディファードレンダリングは通常、人工的に照らされたインテリアや屋外と屋内のライティングを組み合わせたプロジェクトなど、多くの動的ライトを含むシーンを扱う場合に適しています。


>ディファードシェーディング
ディファードシェーディングは、ビルトインレンダーパイプラインで最もライトと影の忠実度が高いレンダリングパスです。
ディファードシェーディングは GPU サポートを必要とし、いくつかの制限があります。半透明のオブジェクト (Unity はフォワードレンダリングを使用)、平行投影 (Unity はカメラにフォワードレンダリングを使用)、ハードウェアのアンチエイリアス (ポストプロセスエフェクトを使用して同様の結果を得られます) をサポートしません。カリングマスクのサポートに制限があり、Renderer.receiveShadows フラグを常に true として扱います。
プロジェクトに多数のリアルタイムのライトがあり、高いレベルのライティングの忠実度が必要で、ターゲットハードウェアがディファードシェーディングをサポートしている場合、このレンダリングパスはプロジェクトに適しています。

このレンダリングパスの制限を含む詳細は、[ディファードシェーディングレンダリングパス](https://docs.unity3d.com/ja/2023.2/Manual/RenderTech-DeferredShading.html)のページを参照してください。


# フォワード vs ディファードの比較

## フォワードレンダリング
```:基本的な仕組み
オブジェクト1 → ライティング計算 → 描画
オブジェクト2 → ライティング計算 → 描画
オブジェクト3 → ライティング計算 → 描画

1. オブジェクト1を描画
   → シェーディング計算（表面の明暗）
   → 影の計算（シャドウマップをサンプリング）
   → 最終色を決定

2. オブジェクト2を描画
   → 同様の処理...
```
- 特徴
  - オブジェクトを1つずつ順番に処理
  - 各オブジェクトに対して、その場でライティング計算を実行
  - シンプルで理解しやすい


メリット
✅ 透明オブジェクトの処理が得意
✅ メモリ使用量が少ない
✅ シンプルなシーンでは高速
✅ 幅広いハードウェアで動作

デメリット
❌ ライトが多いと急激に重くなる
❌ ライト数に制限がある（URPフォワードでは最大8ライト/オブジェクト）

## ディファード
```:基本的な仕組み
ステップ1: 全オブジェクト → G-Buffer（情報を蓄積）
ステップ2: G-Bufferを使って → 一気にライティング計算


1. 全オブジェクトの基本情報をG-Bufferに保存
2. ライティングパス：
   → シェーディング計算
   → 影の計算
   → 全ピクセルの最終色を決定
```

- 特徴
描画を2段階に分ける
最初にマテリアル情報をバッファに保存
後でまとめてライティング計算

メリット
✅ 大量のライトを効率的に処理
✅ ライト数による性能劣化が少ない
✅ 複雑なライティングシーンに最適

デメリット
❌ メモリ使用量が多い（G-Bufferのため）
❌ 透明オブジェクトは別途フォワードで処理
❌ MSAAアンチエイリアスが使用不可
❌ モバイルでは性能が出にくい


# そもそもマルチパスとは？
フォワードレンダリングが「マルチパス」とはどういうことなのか解明する。

#### 基本的な仕組み
ライトの数だけ、同じオブジェクトを何回も描画する
```:例：1つのキューブに3つのライトが当たっている場合
パス1: キューブを描画（ライト1の効果のみ）
パス2: キューブを描画（ライト2の効果のみ）← 加算合成
パス3: キューブを描画（ライト3の効果のみ）← 加算合成
```
問題点

ライトが10個 → 10回描画
ライトが100個 → 100回描画
ドローコール数が急激に増加 💥

これが、フォワードが多くのライティングに対応せず、8個などの制限をかけている理由。


---
# 参考
[レンダーパイプラインとライティングソリューションの選択と設定 - Unity マニュアル](https://docs.unity3d.com/ja/2023.2/Manual/BestPracticeLightingPipelines.html)

[ビルトインレンダーパイプラインのレンダリングパス - Unity マニュアル](https://docs.unity3d.com/ja/2023.2/Manual/RenderingPaths.html)

[Unity Rendering Paths Explained \| Claude](https://claude.ai/share/f31e005c-aa43-41c3-81f5-62bca83995c2)